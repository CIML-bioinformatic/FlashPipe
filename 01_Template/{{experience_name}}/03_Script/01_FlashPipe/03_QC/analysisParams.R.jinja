###############################################################################
# This file defines ANALYSIS parameters as global variables that will be loaded
# before analysis starts. It should define common parameters used by the current
# analysis
#

######## CONSTANTS ON THE ANALYSIS STEP IDENTITY
######## Modify the ANALYSIS_STEP_NAME and LITERAL_TITLE variable

# This is the literal title of the analysis step. It will be shown at the beginning
# of the HTML report
# Example : LITERAL_TITLE = "Quality Control, normalization and clustering"
LITERAL_TITLE = "Quality control of FlashPipe"

# This is the name of the analysis step. Use the same name as the folder
# name of the analysis step
# Example : ANALYSIS_STEP_NAME = "02_GlobalHeterogeneity"
ANALYSIS_STEP_NAME = "03_QC"

# Params for analysis, and the QC to adapt the résult in the HTML with the good option.
# This section will be completed by “Copier” automatically.
# Exemple : PARAMS_METHOD = single-cell / PARAMS_INDEXSORT = FALSE / PARAMS_BCR = TRUE / ...
PARAMS_METHOD = "{{method_analysis}}"
PARAMS_INDEXSORT = {{index_sort_analysis}}
PARAMS_BCR = {{bcr_repertoire_analysis}}
PARAMS_TCR = {{tcr_repertoire_analysis}}
PARAMS_METADATA = {{metadata_analysis}}

# Load FlashPipe configuration file filled in for user, plus check that it exists.
PATH_CONFIG_FILE = file.path( PATH_EXPERIMENT_REFERENCE, "Config_FlashPipe.yml")
if (PATH_CONFIG_FILE == ""){
  error_intialisation <- c(error_intialisation, "ERROR : Path to user config file (Config_FlashPipe.yml) in R is empty (PATH_CONFIG_FILE)")
}
CONFIG_FILE_YAML = yaml::yaml.load_file(PATH_CONFIG_FILE)

# Recover the values present in the FlashPipe configuration file
## The purpose of this section is to check whether or not there have been any changes in the data.
method_analysis = gsub( " ", "", strsplit( CONFIG_FILE_YAML$method_analysis[[1]], fixed= TRUE, split = ",")[[1]])
indexsort_analysis <- as.logical(toupper(gsub(" ", "", CONFIG_FILE_YAML$index_sort_analysis[[1]])))
bcr_repertoire <- as.logical(toupper(gsub(" ", "", CONFIG_FILE_YAML$bcr_repertoire_analysis[[1]])))
tcr_repertoire <- as.logical(toupper(gsub(" ", "", CONFIG_FILE_YAML$tcr_repertoire_analysis[[1]])))
metadata_analysis <- as.logical(toupper(gsub(" ", "", CONFIG_FILE_YAML$metadata_analysis[[1]])))

# Check that previous parameters in the file match any new ones (especially if the second snakemake is relaunched)
# We store the various warning in variables in order to display them all together instead of stopping the code at each warning.
error_in_config_file <- c()
if (PARAMS_METHOD != method_analysis){
  PARAMS_METHOD = method_analysis
  error_in_config_file <- c(error_in_config_file, paste0("The mode ", PARAMS_METHOD, " will be selected for the analysis method."))
}
if (PARAMS_INDEXSORT != indexsort_analysis){
  PARAMS_INDEXSORT = indexsort_analysis
  error_in_config_file <- c(error_in_config_file, paste0("IndexSort analysis will be set on ", PARAMS_INDEXSORT))
}
if (PARAMS_BCR != bcr_repertoire){
  PARAMS_BCR = bcr_repertoire
  error_in_config_file <- c(error_in_config_file, paste0("BCR directory analysis will be set to ", PARAMS_BCR))
}
if (PARAMS_TCR != tcr_repertoire){
  PARAMS_TCR = tcr_repertoire
  error_in_config_file <- c(error_in_config_file, paste0("TCR directory analysis will be set to ", PARAMS_TCR))
}
if (PARAMS_METADATA != metadata_analysis){
  PARAMS_METADATA = metadata_analysis
  error_in_config_file <- c(error_in_config_file, paste0("Metadata analysis will be set to ", PARAMS_METADATA))
}

# Display errors if any were found
if (length(error_in_config_file) > 0) {
  header <- "\n============== Inconsistencies were found between the analysis parameters ==============\n"
  # Numbering of all errors found in this section
  error_list <- paste0(seq_along(error_in_config_file), ". ", error_in_config_file, collapse = "\n")
  # Final message
  full_message <- paste0(header, error_list, "\n================================================================================================\n")
  # Displays and stops
  warning(full_message)
}

# Environment cleanup: removes temporary objects
rm(error_in_config_file)
rm(method_analysis)
rm(indexsort_analysis)
rm(bcr_repertoire)
rm(tcr_repertoire)
rm(metadata_analysis)

# We come to setup the path of files automatically set up by Copier, and check if the paths exist to avoid any errors.
# Initialize an error list
error_intialisation <- c()
# This is the path to the analysis step output folder. It will be automatically created at first analysis launch
PATH_ANALYSIS_OUTPUT = file.path( PATH_FLASHPIPE_OUTPUT, ANALYSIS_STEP_NAME)
if (PATH_ANALYSIS_OUTPUT == ""){
  error_intialisation <- c(error_intialisation, "ERROR : Path to 03_QC in R is empty (PATH_ANALYSIS_OUTPUT) ")
}
PATH_ZUMIS_OUTPUT = file.path( PATH_FLASHPIPE_OUTPUT, "01_zUMIs")
if (PATH_ZUMIS_OUTPUT == ""){
  error_intialisation <- c(error_intialisation, "ERROR : Path to the zUMIs output directory (01_zUMIs) in R is empty (PATH_ZUMIS_OUTPUT)")
}
PATH_EXPERIMENT = file.path( PATH_EXPERIMENT_REFERENCE, "00_Experiment")
if (PATH_EXPERIMENT == ""){
  error_intialisation <- c(error_intialisation, "ERROR : Path to the experiment directory (00_experiment) in R is empty (PATH_EXPERIMENT)")
}
PATH_WELL_BARCODE_FILE = file.path( PATH_EXPERIMENT, "cell_barcode_well.csv")
if (PATH_WELL_BARCODE_FILE == ""){
  error_intialisation <- c(error_intialisation, "ERROR : Path to cell_barcode file in R is empty (PATH_WELL_BARCODE_FILE)")
}
PATH_ERCC_CONCENTRATION = file.path( PATH_EXPERIMENT, "ERCC_concentration.csv")
if (PATH_ERCC_CONCENTRATION == ""){
  error_intialisation <- c(error_intialisation, "ERROR : Path to the ERCC_concentration file in R is empty (PATH_ERCC_CONCENTRATION)")
}
PATH_GSF = "{{gsf_file}}"
if(PARAMS_METADATA){
  if (PATH_GSF == ""){
    error_intialisation <- c(error_intialisation, "ERROR : Path to GSF in R is empty (PATH_GSF)")
  } 
}

if (PARAMS_BCR | PARAMS_TCR){
  PATH_TRUST4_OUTPUT = file.path( PATH_FLASHPIPE_OUTPUT, "02_trust4")
  if (PATH_TRUST4_OUTPUT == ""){
    error_intialisation <- c(error_intialisation, "ERROR : Path to Trust4 output directory (02_trust4) in R is empty (PATH_TRUST4_OUTPUT)")
  }
}

######## CONSTANTS USED BY THE ANALYSIS STEP
######## Add here all the constants required for the analysis
ATTOMOLE_TO_MOLECULE =  602214.1499989164
UL_BY_WELL = 2.5e-8

# Params constans used for all the analysis
COLUMN_HEADER_WELL_ID = "WellID"
COLUMN_HEADER_PLATE_NAME = "Plate_Name"
COLUMN_HEADER_STATISTIC = "Statistic"
COLUMN_HEADER_CELL_ID = "cell_id"
DATAFRAME_FOR_METADATA_SEURAT <- NULL

# Params constants used for TRUST4
COLUMN_HEADER_C_CALL = "c_call"
COLUMN_HEADER_V_CALL = "v_call"
COLUMN_HEADER_J_CALL = "j_call"
COLUMN_HEADER_PRODUCTIVE = "productive"
COLUMN_HEADER_CLASS_CALL = "c_call_class"
COLUMN_HEADER_CHAIN_COMPOSITION = "chain_composition"

# Constant containing the set of colors to be used in the various figures.
GENERAL_COLOR_PANEL = c("#65c44f", "#7c64d4", "#abb739", "#d43c55", "#3fc1bf", "#c050b5", "#5e9dd7", "#d59d69", "#d5542e", "#6e6fb9", "#d59a35", "#737027",
                        "#4b8138", "#4e9830", "#9e5c2a", "#cf89c5", "#99aa5e", "#cd6f6d", "#39855f", "#ba497a", "#5ec287", "#e377c2", "#1f77b4", "#ff7f0e", 
                        "#2ca02c", "#d62728", "#9467bd", "#8c564b", "#e7969c", "#bcbd22", "#17becf", "#aec7e8", "#ffbb78", "#98df8a", "#ff9896", "#c5b0d5", 
                        "#c49c94", "#f7b6d2", "#c7c7c7", "#dbdb8d", "#9edae5")

# Take the values present in the “Categorial_term_set” column in the FlashPipe configuration file for 
# the names of the columns to be added to index sort file (other than fluorescence markers).
if ( !is.null(CONFIG_FILE_YAML$not_fluorescent)){
  not_fluorescent_list = gsub( " ", "", strsplit( CONFIG_FILE_YAML$not_fluorescent[[1]], fixed= TRUE, split = ",")[[1]])
  NOT_FLUORESCENT = as.vector(unlist(not_fluorescent_list))
  if (length(NOT_FLUORESCENT) < 1){
    error_intialisation <- c(error_intialisation, "\nERROR : The column names in NOT_FLUORESCENT are empty in R")
  }
  if (COLUMN_HEADER_WELL_ID %in% NOT_FLUORESCENT) {
    NOT_FLUORESCENT = NOT_FLUORESCENT[! NOT_FLUORESCENT %in% COLUMN_HEADER_WELL_ID]
  }
  rm(not_fluorescent_list)
}

# Display errors if any were found 
if (length(error_intialisation) > 0) {
  # Creates a header
  header <- "\n============== ERROR(S) DETECTED IN SETUP R (Analysis Params) FROM SCRIPT 'analysisParams.R' ==============\n"
  # Numbering of all errors found in this section
  error_list <- paste0(seq_along(error_intialisation), ". ", error_intialisation, collapse = "\n")
  # Final message
  full_message <- paste0(header, error_list, "\n================================================================================================\n")
  # Displays and stops
  stop(full_message)
}
rm(error_intialisation)
